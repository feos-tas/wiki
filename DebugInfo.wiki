#summary Тонкости дебага

||PRG ROM||16 x 16KiB||
||CHR ROM||0 x  8KiB||
||Mapper #||7||
||Mapper name||ANROM||
||Mirroring||Horizontal||

16 оригинальных банков по 16KiB распознаются лоадером для IDA как 8 по 32KiB. При поиске адреса, отображаемого IDA, в дебаггере FCEUX - следует просто умножить банк IDA на 2.

----

Брейкпоинты для определения поломки счетчика объектов:

`$863C: EC--X-: K==#C&&Y>#16`

`$8990: EC--X-: K==#C&&Y>#F`

Можно использовать LUA-скрипт:
{{{
function CounterBreak()
	ObjCtr = memory.getregister("y")
	if ObjCtr > 0x16 then 
		gui.text(1,1,string.format("%02X",ObjCtr))
		emu.pause() 
	end
end
memory.registerexecute(0x863C, CounterBreak);
}}}

----

Шина - это не хранилище, шина это только тоннель для передачи данных. так что ничем она не может быть забита. Когда процессор пытается читать данные по определённому адресу системной шины данных, он получает данные не из шины, а из устройства, за которым закреплён этот участок адресов. Короче, вспомни про дешифровку адреса. Читаешь из адреса 0-1FFF - получаешь в ответ восемь сигналов от модуля памяти, то есть восемь бит, один байт, равный значению этой ячейки RAM. То же самое при записи, только здесь сигналы по шине идут от процессора к RAM.

А если читать из адреса, которому не соответствует ни одно устройство, это критическая ситуация, и тут уже всё зависит уже от электроники. В современных архитектурах предусмотрены всякие "ошибки доступа к памяти" и "исключения", в общем, в Винде был бы просто синий экран смерти. Но на NES никаких проверок нет, процессор выдал шине адрес и с умным видом читает из шины восемь сигналов. А шине неоткуда взять эти сигналы, т.к. по этому адресу не подключено ни одно устройство для их генерации. Зато шина, как любой проводник, так или иначе накапливает электрический заряд. Так что процессор получает значения последних восьми сигналов, которые проходили по шине. В твоём случае с Жабами это сначала 0x75, т.к. это старший байт операнда команды косвенного прыжка JMP, прочитанный из ROM последним. Вот копии этого 75 и возвращается (дважды), получается 7575, что соответствует опкоду "ADC 75". Команда ADC $75 читает из RAM по адресу $75 и корректно получает имеющееся там значение 6F (передаваемое, ясное дело, по шине). После этого в конденсаторах оседает уже не 0x75, а 0x6F, оно и возвращается при следующих чтениях из открытой шины. Т.к. 6F не является корректной инструкцией, процессор её просто игнорирует и читает следующую команду, увеличивая адрес чтения на 1. Адрес следующей команды тоже не соответствует ни одному устройству, поэтому опять возвращаются ёмкостные данные, а они как были 6F, так и остались (хотя в реале я даже не знаю, может быть, бесконечно это не может продолжаться). И так некорректный адрес растёт до тех пор, пока не дойдёт до $8000, где шина наконец-то свяжет его с маппером, а тот уже выдаст данные из ROM. Удивительно, что после такого путешествия состояние игры корректно восстанавливается.